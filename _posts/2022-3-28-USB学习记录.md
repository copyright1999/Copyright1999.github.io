---
layout:     post   				    # 使用的布局（不需要改）
title:     解决win10磁盘利用率100%问题			# 标题 
subtitle:  
date:       2020-05-12				# 时间
author:     婷                               # 作者
header-img: img/51.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签

- win10

---



## 1





## 笔记

### 命名规范

![image-20220227221156747](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220227221156747.png)



```shell
root@ATK-IMX6U:/dev/input# dmesg | grep usbcore
[    0.297604] usbcore: registered new interface driver usbfs
[    0.297791] usbcore: registered new interface driver hub
[    0.298007] usbcore: registered new device driver usb
[    1.983790] usbcore: registered new interface driver asix
[    1.989390] usbcore: registered new interface driver ax88179_178a
[    1.995733] usbcore: registered new interface driver cdc_ether
[    2.001763] usbcore: registered new interface driver net1080
[    2.007663] usbcore: registered new interface driver cdc_subset
[    2.013806] usbcore: registered new interface driver zaurus
[    2.019685] usbcore: registered new interface driver cdc_ncm
[    2.037911] usbcore: registered new interface driver usb-storage
[    2.044316] usbcore: registered new interface driver usb_ehset_test
[    2.563789] usbcore: registered new interface driver bcm203x
[    2.569723] usbcore: registered new interface driver btusb
[    2.575526] usbcore: registered new interface driver ath3k
[    2.801916] usbcore: registered new interface driver usbhid
```



## USB虚拟网卡技术



## USB 抓包模块

### USB Monitor

这里介绍内核的一个`USB`抓包分析工具，打开`USB Monitor`选项，编译出`usbmon.ko`。

![image-20220227222733791](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220227222733791.png)



![image-20220227222630179](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220227222630179.png)



![image-20220227232825933](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220227232825933.png)



内核中`Documentation/usb/usbmon.txt`[文档](https://www.kernel.org/doc/Documentation/usb/usbmon.txt?spm=a2c6h.12873639.0.0.6eb321c7PF5wNo&file=usbmon.txt)有对该驱动如何抓包的详细说明。根据该文档，先挂载`debugfs`，然后加载驱动，查看总线上的设备。（不过我的系统已经挂载了`debugfs`了）

![image-20220313205819045](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220313205819045.png)



输入`ls /sys/kernel/debug/usb/usbmon/`，`2u`其实是我的鼠标

![image-20220313205848965](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220313205848965.png)

`cat /sys/kernel/debug/usb/usbmon/2u > ~/1.mon.out`

![image-20220313210246165](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220313210246165.png)



查看抓包后得到的文件，这里我只截取前20行

![image-20220313210407179](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220313210407179.png)



```shell
/:~# cat 1.mon.out | head -n 20
94031280 3104390238 C Ii:2:004:1 0:2 7 = 0200ff0f 000000
94031280 3104390348 S Ii:2:004:1 -115:2 8 <
94031280 3104394235 C Ii:2:004:1 0:2 7 = 0200fe0f 000000
94031280 3104394325 S Ii:2:004:1 -115:2 8 <
94031280 3104398219 C Ii:2:004:1 0:2 7 = 0200fe0f 000000
94031280 3104398297 S Ii:2:004:1 -115:2 8 <
94031280 3104402218 C Ii:2:004:1 0:2 7 = 0200fc0f 000000
94031280 3104402304 S Ii:2:004:1 -115:2 8 <
94031280 3104406219 C Ii:2:004:1 0:2 7 = 0200fcff ff0000
94031280 3104406306 S Ii:2:004:1 -115:2 8 <
94031280 3104410235 C Ii:2:004:1 0:2 7 = 0200fd0f 000000
94031280 3104410323 S Ii:2:004:1 -115:2 8 <
94031280 3104414217 C Ii:2:004:1 0:2 7 = 0200fcff ff0000
94031280 3104414303 S Ii:2:004:1 -115:2 8 <
94031280 3104418220 C Ii:2:004:1 0:2 7 = 0200faff ff0000
94031280 3104418301 S Ii:2:004:1 -115:2 8 <
94031280 3104426247 C Ii:2:004:1 0:2 7 = 0200fa0f 000000
94031280 3104426335 S Ii:2:004:1 -115:2 8 <
94031280 3104430235 C Ii:2:004:1 0:2 7 = 0200fb0f 000000
94031280 3104430319 S Ii:2:004:1 -115:2 8 <
```

具体各项是什么意思 则需要后续去深究

### WireShark USB协议抓取分析



## libusb-1.0.24.tar.bz2

基于usbfs的应用传输API可参考如下libusb-1.0.24.tar.bz2源码，证实可用，tests目录下文件测试可用，注意usbfs挂载路径

https://github.com/libusb/libusb/releases



![image-20220305225307984](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220305225307984.png)



tar -jxvf libusb-1.0.25.tar.bz2

![image-20220305225619237](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220305225619237.png)



```shell
#!/bin/bash
aclocal
autoheader
automake -a
autoconf
./configure
# ./configure --host=arm-linux CC=arm-linux-gcc  CXX=arm-linux-g++
make
```





![image-20220305230059097](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220305230059097.png)

./configure --host=arm-linux CC=arm-linux-gnueabihf-gcc  CXX=arm-linux-gnueabihf-g++  --disable-udev

https://blog.csdn.net/xfc_1939/article/details/53422071

![image-20220305230231763](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220305230231763.png)





![image-20220305234658043](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220305234658043.png)



```shell
checking libudev.h presence... no
checking for libudev.h... no
configure: error: udev support requested but libudev header not installed
copyright@copyright-Vostro-3559:~/libusb/libusb-1.0.25$ make
make: *** 没有指明目标并且找不到 makefile。 停止。

```







![image-20220305235229562](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220305235229562.png)

make





然后还要写用到了usbfs的应用层API

![image-20220305235640607](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220305235640607.png)





是个脚本。。。。





## USB协议简单了解

### USB描述符

`USB` 描述符用来描述` USB `信息，描述符就是一串按照一定规则构建的字符串，`USB `设备使用描述符来向主机报告自己的相关属性信息。下面是常见的`USB`描述符。



| 描述符类型               | 名字         | 数值 | 内容                                                         |
| ------------------------ | ------------ | ---- | ------------------------------------------------------------ |
| Device Descriptor        | 设备描述符   | 1    | 只能有一个，描述一般信息，比如USB 版本号、设备类型、VID(厂商 ID)、PID(产品 ID)、设备序列号等。 |
| Configuration Descriptor | 配置描述符   | 2    | 设备可提供的接口(Interface)数量、配置编号、 供电信息等       |
| String Descriptor        | 字符串描述符 | 3    |                                                              |
| Interface Descriptor     | 接口字符串   | 4    |                                                              |
| Endpoint Descriptor      | 端点描述符   | 5    |                                                              |











#### 设备描述符 usb_device_descriptor

设备描述符用于描述 USB 设备的一般信息，USB 设备**只有一个**设备描述符。设备描述符 里面记录了设备的 USB 版本号、设备类型、VID(厂商 ID)、PID(产品 ID)、设备序列号等。



https://docs.huihoo.com/doxygen/linux/kernel/3.7/structusb__device__descriptor.html



vim include/uapi/linux/usb/ch9.h  +263



```c
/* USB_DT_DEVICE: Device descriptor */
struct usb_device_descriptor {
        __u8  bLength;
        __u8  bDescriptorType;

        __le16 bcdUSB;
        __u8  bDeviceClass;
        __u8  bDeviceSubClass;
        __u8  bDeviceProtocol;
        __u8  bMaxPacketSize0;
        __le16 idVendor;
        __le16 idProduct;
        __le16 bcdDevice;
        __u8  iManufacturer;
        __u8  iProduct;
        __u8  iSerialNumber;
        __u8  bNumConfigurations;
} __attribute__ ((packed));

```



![image-20220305213246542](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220305213246542.png)







| 变量                      | 值类型 | 描述                                      |
| ------------------------- | ------ | ----------------------------------------- |
| __u8  bLength;            | 数字   | 此设备描述符长度，18 个字节               |
| u8  bDescriptorType;      | 常量   | 描述符类型，为 0X01                       |
| __le16 bcdUSB;            | BCD 码 | USB 版本号，比如2.0                       |
| __u8  bDeviceClass;       | 类     | 设备类(由USB官方分配)                     |
| u8  bDeviceSubClass;      | 子类   | 设备子类(由USB官方分配)                   |
| u8  bDeviceProtocol;      | 协议   | 设备协议(由USB官方分配)                   |
| u8  bMaxPacketSize0;      | 数字   | 端点 0 的最大包长度(有效大小为8,16,32,64) |
| le16 idVendor;            | ID     | 厂商 ID                                   |
| le16 idProduct;           | ID     | 产品 ID                                   |
| le16 bcdDevice;           | BCD 码 | 设备版本号                                |
| u8  iManufacturer;        | 索引   | 字符串描述符中厂家ID的索引                |
| u8  iProduct;             | 索引   | 字符串描述符中产品ID的索引                |
| __u8  iSerialNumber;      | 索引   | 字符串描述符中设备序列号的索引            |
| __u8  bNumConfigurations; | 索引   | 配置描述符的个数,表示有多少个配置描述符   |

(最后自己都是索引喽 只想其他的描述符)

设备类有哪些 看代码以及别人的分析

还是同个文件ch9.h

www.usb.org可以去看更多的东西

![image-20220305220642498](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220305220642498.png)



```c
#define USB_CLASS_PER_INTERFACE         0       /* for DeviceClass */
#define USB_CLASS_AUDIO                 1
#define USB_CLASS_COMM                  2
#define USB_CLASS_HID                   3
#define USB_CLASS_PHYSICAL              5
#define USB_CLASS_STILL_IMAGE           6
#define USB_CLASS_PRINTER               7
#define USB_CLASS_MASS_STORAGE          8
#define USB_CLASS_HUB                   9
#define USB_CLASS_CDC_DATA              0x0a
#define USB_CLASS_CSCID                 0x0b    /* chip+ smart card */
#define USB_CLASS_CONTENT_SEC           0x0d    /* content security */
#define USB_CLASS_VIDEO                 0x0e
#define USB_CLASS_WIRELESS_CONTROLLER   0xe0
#define USB_CLASS_MISC                  0xef
#define USB_CLASS_APP_SPEC              0xfe
#define USB_CLASS_VENDOR_SPEC           0xff

#define USB_SUBCLASS_VENDOR_SPEC        0xff

```







设备子类

设备协议



#### 配置描述符 usb_config_descriptor

设备描述符的 bNumConfigurations 域定义了一个 USB 设备的配置描述符数量，一个 USB 设备至少有一个配置描述符。配置描述符描述了设备可提供的接口(Interface)数量、配置编号、 供电信息等，配置描述符结构如表 67.3.1.3 所示：





```c
/* USB_DT_CONFIG: Configuration descriptor information.
 *
 * USB_DT_OTHER_SPEED_CONFIG is the same descriptor, except that the
 * descriptor type is different.  Highspeed-capable devices can look
 * different depending on what speed they're currently running.  Only
 * devices with a USB_DT_DEVICE_QUALIFIER have any OTHER_SPEED_CONFIG
 * descriptors.
 */
struct usb_config_descriptor {
        __u8  bLength;
        __u8  bDescriptorType;

        __le16 wTotalLength;
        __u8  bNumInterfaces;
        __u8  bConfigurationValue;
        __u8  iConfiguration;
        __u8  bmAttributes;
        __u8  bMaxPower;
} __attribute__ ((packed));

#define USB_DT_CONFIG_SIZE              9
```





![image-20220305215921795](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220305215921795.png)



| 变量                      | 值类型 | 描述                                                         |
| ------------------------- | ------ | ------------------------------------------------------------ |
| __u8  bLength             | 数字   | 此配置描述符长度，9 个字节                                   |
| __u8  bDescriptorType     | 常量   | 配置描述符类型，为 0X02                                      |
| __le16 wTotalLength       | 数字   | 整个配置信息总长度(包括配置、接口、端点、设备类和厂家定义的描述符) |
| __u8  bNumInterfaces      | 数字   | 此配置所支持的接口数, 表示有多少个接口描述符                 |
| __u8  bConfigurationValue | 数字   | 该配置的值，一个设备支持多种配置，通过配置值来区分不同的配置。`Set_Configuration`命令需要的参数值。 |
| __u8  iConfiguration      | 数字   | 描述此配置的字符串描述索引                                   |
| __u8  bmAttributes        | 数字   | 供电模式的选择 D7：保留 D6：自给电源 D5：远程唤醒 D4:0：保留 |
| __u8  bMaxPower           | 数字   | 此配置下所需的总线电流(单位 2mA)                             |



#### 字符串描述符

字符串描述符是可选的，字符串描述符用于描述一些方便人们阅读的信息，比如制造商、 设备名称啥的。如果一个设备没有字符串描述符，那么其他描述符中和字符串有关的索引值都 必须为 0，字符串描述符结构如表 67.3.1.4 所示：

#### 接口描述符







#### 端点描述符

接口描述符定义了其端点数量，端点是设备与主机之间进行数据传输的逻辑接口，除了端 点 0 是双向端口，其他的端口都是单向的。端点描述符描述了树传输类型、方向、数据包大小、 端点号等信息，



![image-20220305223208232](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220305223208232.png)



```c
/* USB_DT_ENDPOINT: Endpoint descriptor */
struct usb_endpoint_descriptor {
        __u8  bLength;
        __u8  bDescriptorType;

        __u8  bEndpointAddress;
        __u8  bmAttributes;
        __le16 wMaxPacketSize;
        __u8  bInterval;

        /* NOTE:  these two are _only_ in audio endpoints. */
        /* use USB_DT_ENDPOINT*_SIZE in bLength, not sizeof. */
        __u8  bRefresh;
        __u8  bSynchAddress;
} __attribute__ ((packed));

```

| 变量                   | 值类型 | 描述                                                         |
| ---------------------- | ------ | ------------------------------------------------------------ |
| __u8  bLength          | 数字   | 此端点描述符长度，7 个字节                                   |
| __u8  bDescriptorType  | 常量   | 描述符类型，为 0X05                                          |
| __u8  bEndpointAddress | 数字   | 端点地址和方向： bit3:0：端点号 bit6:4：保留，为零。 bit7：方向，0 输出端点(主机到设 备)，1 输入端点(设备到主机) |
| __u8  bmAttributes     | 数字   | 端点属性，bit1:0 表示传输类型： 00：控制传输 01：同步传输 10：批量传输 11：中断传输 其他位保留 |
| __le16 wMaxPacketSize  | 数字   | 端点能发送或接收的最大数据包长度                             |
| __u8  bInterval        | 子类   | 端点数据传输中周期时间间隙值，此 域对于批量传输和控制传输无效，同 步传输的话此域必须为 1ms，中断传 输此域可以设置 1ms~255ms。 |
| __u8  bRefresh         |        |                                                              |
| __u8  bSynchAddress    |        |                                                              |



### USB数据包

### USB枚举

## USB wifi 

腾讯的网卡

## USB 4G



## 参考链接

https://developer.aliyun.com/article/837788

usbmon





http://www.usbzh.com/article/detail-330.html  tcpdump指定监听某个usb设备

## 其他

自己项目中usb虚拟网卡技术

其实就是usb网卡啦 自己之前不也是在腾旭买了一个吗。。。

腾讯的网卡

![image-20220227232427272](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220227232427272.png)

貌似没使能驱动？？？、

![image-20220227232512372](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220227232512372.png)



网卡名字也没有

挂在debugfs后就发现其实没有驱动匹配

![image-20220305214219054](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220305214219054.png)







## 其他2 待整理 插入wifi网卡跟鼠标

```shell
[   21.352622] random: nonblocking pool is initialized
[  470.282621] usb 2-1.1: new high-speed USB device number 3 using ci_hdrc
[  490.002653] usb 2-1.4: new full-speed USB device number 4 using ci_hdrc
[  490.130912] input: 2.4G Mouse as /devices/platform/soc/2100000.aips-bus/2184200.usb/ci_hdrc.1/usb2/2-1/2-1.4/2-1.4:1.0/0003:1EA7:0064.0001/input/input3
[  490.164640] hid-generic 0003:1EA7:0064.0001: input: USB HID v1.10 Mouse [2.4G Mouse] on usb-ci_hdrc.1-1.4/input0

```

![image-20220306132446923](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220306132446923.png)





```shell
root@ATK-IMX6U:~# lsusb
Bus 002 Device 004: ID 1ea7:0064
Bus 002 Device 003: ID 7392:7822
Bus 001 Device 001: ID 1d6b:0002
Bus 002 Device 002: ID 05e3:0608
Bus 002 Device 001: ID 1d6b:0002

```



![image-20220306132520370](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220306132520370.png)





```shell
root@ATK-IMX6U:~# cd /sys/kernel/debug/usb/
root@ATK-IMX6U:/sys/kernel/debug/usb# cat devices

T:  Bus=02 Lev=00 Prnt=00 Port=00 Cnt=00 Dev#=  1 Spd=480  MxCh= 1
B:  Alloc=  2/800 us ( 0%), #Int=  2, #Iso=  0
D:  Ver= 2.00 Cls=09(hub  ) Sub=00 Prot=01 MxPS=64 #Cfgs=  1
P:  Vendor=1d6b ProdID=0002 Rev= 4.01
S:  Manufacturer=Linux 4.1.15 ehci_hcd
S:  Product=EHCI Host Controller
S:  SerialNumber=ci_hdrc.1
C:* #Ifs= 1 Cfg#= 1 Atr=e0 MxPwr=  0mA
I:* If#= 0 Alt= 0 #EPs= 1 Cls=09(hub  ) Sub=00 Prot=00 Driver=hub
E:  Ad=81(I) Atr=03(Int.) MxPS=   4 Ivl=256ms

T:  Bus=02 Lev=01 Prnt=01 Port=00 Cnt=01 Dev#=  2 Spd=480  MxCh= 4
D:  Ver= 2.00 Cls=09(hub  ) Sub=00 Prot=01 MxPS=64 #Cfgs=  1
P:  Vendor=05e3 ProdID=0608 Rev=85.36
S:  Product=USB2.0 Hub
C:* #Ifs= 1 Cfg#= 1 Atr=e0 MxPwr=100mA
I:* If#= 0 Alt= 0 #EPs= 1 Cls=09(hub  ) Sub=00 Prot=00 Driver=hub
E:  Ad=81(I) Atr=03(Int.) MxPS=   1 Ivl=256ms

T:  Bus=02 Lev=02 Prnt=02 Port=00 Cnt=01 Dev#=  3 Spd=480  MxCh= 0
D:  Ver= 2.00 Cls=00(>ifc ) Sub=00 Prot=00 MxPS=64 #Cfgs=  1
P:  Vendor=7392 ProdID=7822 Rev= 2.00
S:  Manufacturer=Realtek
S:  Product=802.11n WLAN Adapter
S:  SerialNumber=00e04c000001
C:* #Ifs= 1 Cfg#= 1 Atr=80 MxPwr=500mA
I:* If#= 0 Alt= 0 #EPs= 4 Cls=ff(vend.) Sub=ff Prot=ff Driver=(none)
E:  Ad=81(I) Atr=02(Bulk) MxPS= 512 Ivl=0ms
E:  Ad=02(O) Atr=02(Bulk) MxPS= 512 Ivl=0ms
E:  Ad=03(O) Atr=02(Bulk) MxPS= 512 Ivl=0ms
E:  Ad=84(I) Atr=03(Int.) MxPS=  64 Ivl=125us

T:  Bus=02 Lev=02 Prnt=02 Port=03 Cnt=02 Dev#=  4 Spd=12   MxCh= 0
D:  Ver= 1.10 Cls=00(>ifc ) Sub=00 Prot=00 MxPS= 8 #Cfgs=  1
P:  Vendor=1ea7 ProdID=0064 Rev= 2.00
S:  Product=2.4G Mouse
C:* #Ifs= 1 Cfg#= 1 Atr=a0 MxPwr=100mA
I:* If#= 0 Alt= 0 #EPs= 1 Cls=03(HID  ) Sub=01 Prot=02 Driver=usbhid
E:  Ad=81(I) Atr=03(Int.) MxPS=   8 Ivl=2ms

T:  Bus=01 Lev=00 Prnt=00 Port=00 Cnt=00 Dev#=  1 Spd=480  MxCh= 1
B:  Alloc=  0/800 us ( 0%), #Int=  0, #Iso=  0
D:  Ver= 2.00 Cls=09(hub  ) Sub=00 Prot=01 MxPS=64 #Cfgs=  1
P:  Vendor=1d6b ProdID=0002 Rev= 4.01
S:  Manufacturer=Linux 4.1.15 ehci_hcd
S:  Product=EHCI Host Controller
S:  SerialNumber=ci_hdrc.0
C:* #Ifs= 1 Cfg#= 1 Atr=e0 MxPwr=  0mA
I:* If#= 0 Alt= 0 #EPs= 1 Cls=09(hub  ) Sub=00 Prot=00 Driver=hub
E:  Ad=81(I) Atr=03(Int.) MxPS=   4 Ivl=256ms
root@ATK-IMX6U:/sys/kernel/debug/usb#

```



![image-20220306132621378](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220306132621378.png)



![image-20220306132638102](D:\code_for_github\Copyright1999_Blog\_posts\2022-3-7-USB学习记录.assets\image-20220306132638102.png)

```shell

```







```shell

```

